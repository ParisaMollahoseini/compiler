Nonterminals useless in grammar

   $@1
   $@2
   FTYPE
   PARAMS
   VTYPE
   STMTS
   DECLARE_STMT
   $@3
   $@4
   IDS
   $@5


Terminals unused in grammar

   ','
   COND_OR
   COND_AND
   LOG_OR
   LOG_XOR
   LOG_AND
   ISNOTEQ
   ISEQ
   ISHIGHERANDEQ
   ISHIGHER
   ISLOWERANDEQ
   ISLOWER
   '+'
   '-'
   '*'
   '/'
   NOT
   '('
   ')'
   '['
   ']'
   '$'
   VALUE_ID
   EQ
   MULTI_COMMENT
   COMMENT
   INTVAL
   ID
   char_val
   CHAR
   VOID
   INT
   CONTINUE
   BREAK
   RETURN
   MAIN
   FOR
   ELSE
   ELSEIF
   WHILE
   IF
   '{'
   '}'


Rules useless in grammar

    2 $@1: /* empty */

    3 $@2: /* empty */

    4 PROGRAM: FTYPE ID '(' PARAMS $@1 ')' '{' STMTS '}' $@2 PROGRAM

    5 FTYPE: VOID
    6      | INT

    7 PARAMS: /* empty */
    8       | VTYPE ID
    9       | VTYPE ID ',' VTYPE ID
   10       | VTYPE ID ',' VTYPE ID ',' VTYPE ID
   11       | VTYPE ID ',' VTYPE ID ',' VTYPE ID ',' VTYPE ID

   12 VTYPE: CHAR
   13      | INT

   14 STMTS: DECLARE_STMT

   15 $@3: /* empty */

   16 DECLARE_STMT: VTYPE ID $@3 IDS '$' STMTS

   17 $@4: /* empty */

   18 DECLARE_STMT: CHAR ID EQ char_val $@4 '$' STMTS

   19 IDS: /* empty */

   20 $@5: /* empty */

   21 IDS: ',' ID $@5 IDS


Grammar

    0 $accept: PROGRAM $end

    1 PROGRAM: ENTER


Terminals, with rules where they appear

$end (0) 0
'$' (36)
'(' (40)
')' (41)
'*' (42)
'+' (43)
',' (44)
'-' (45)
'/' (47)
'[' (91)
']' (93)
'{' (123)
'}' (125)
error (256)
COND_OR (258)
COND_AND (259)
LOG_OR (260)
LOG_XOR (261)
LOG_AND (262)
ISNOTEQ (263)
ISEQ (264)
ISHIGHERANDEQ (265)
ISHIGHER (266)
ISLOWERANDEQ (267)
ISLOWER (268)
NOT (269)
ENTER (270) 1
VALUE_ID (271)
EQ (272)
MULTI_COMMENT (273)
COMMENT (274)
INTVAL (275)
ID (276)
char_val (277)
CHAR (278)
VOID (279)
INT (280)
CONTINUE (281)
BREAK (282)
RETURN (283)
MAIN (284)
FOR (285)
ELSE (286)
ELSEIF (287)
WHILE (288)
IF (289)


Nonterminals, with rules where they appear

$accept (47)
    on left: 0
PROGRAM (48)
    on left: 1, on right: 0


state 0

    0 $accept: . PROGRAM $end

    ENTER  shift, and go to state 1

    PROGRAM  go to state 2


state 1

    1 PROGRAM: ENTER .

    $default  reduce using rule 1 (PROGRAM)


state 2

    0 $accept: PROGRAM . $end

    $end  shift, and go to state 3


state 3

    0 $accept: PROGRAM $end .

    $default  accept
